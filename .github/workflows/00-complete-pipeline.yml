# =============================================================================
# Complete DevSecOps Pipeline - All 4 Phases with Job Dependencies
# =============================================================================
# This workflow demonstrates defense-in-depth security with sequential gates:
#
# Flow:
#   1. security-scan (Phase 2) - SAST with Trivy + Checkov
#        â†“ (must pass)
#   2. policy-check (Phase 2) - OPA policy validation
#        â†“ (must pass)
#   3. deploy (Phase 3) - Terraform deployment with manual approval
#        â†“ (must pass)
#   4. drift-detection (Phase 4) - Infrastructure drift detection
#
# Key Features:
# - Sequential execution enforced with 'needs' keyword
# - Deployment CANNOT run if security scans fail
# - Manual approval required before deployment (GitHub Environment)
# - Drift detection only runs after successful deployment
# - Complete audit trail in GitHub Actions
#
# Triggers:
# - Pull Request: Runs security-scan and policy-check only
# - Push to main: Runs all 4 phases (including deployment)
# - Manual: Can trigger full pipeline manually
# =============================================================================

name: Complete DevSecOps Pipeline

on:
  # Trigger on pull requests to any branch
  pull_request:
    branches:
      - "**"
    paths:
      - "terraform/**"
      - "policies/**"
      - ".github/workflows/**"
      - "tests/**"

  # Trigger on push to main branch (after PR merge)
  push:
    branches:
      - main
    paths:
      - "terraform/**"
      - "policies/**"
      - ".github/workflows/**"

  # Allow manual workflow trigger
  workflow_dispatch:
    inputs:
      skip_deployment:
        description: "Skip deployment (test security scans only)"
        required: false
        default: "false"
        type: choice
        options:
          - "true"
          - "false"

# Permissions for GitHub token
permissions:
  contents: read
  pull-requests: write
  security-events: write

jobs:
  # ===========================================================================
  # Phase 2 - Job 1: Security Scanning with Trivy + Checkov + Gitleaks
  # ===========================================================================
  security-scan:
    name: "Phase 2: Security Scan (Trivy + Checkov + Gitleaks)"
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      # -----------------------------------------------------------------------
      # Trivy - IaC Security Scanner
      # -----------------------------------------------------------------------
      - name: Run Trivy IaC Scanner (Table Output)
        uses: aquasecurity/trivy-action@master
        continue-on-error: true
        with:
          scan-type: "config"
          scan-ref: "terraform/"
          format: "table"
          severity: "CRITICAL,HIGH,MEDIUM"

      - name: Run Trivy IaC Scanner (JSON Output)
        id: trivy
        uses: aquasecurity/trivy-action@master
        continue-on-error: true
        with:
          scan-type: "config"
          scan-ref: "terraform/"
          format: "json"
          output: "trivy-results.json"
          severity: "CRITICAL,HIGH,MEDIUM"
          exit-code: "1"
        # Continue on error to allow all scanners to run and upload results

      - name: Upload Trivy JSON Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-scan-results
          path: trivy-results.json
          retention-days: 30

      # -----------------------------------------------------------------------
      # Checkov - SAST for Infrastructure as Code
      # -----------------------------------------------------------------------
      - name: Run Checkov SAST Scanner
        id: checkov
        uses: bridgecrewio/checkov-action@master
        continue-on-error: true
        with:
          directory: terraform/
          framework: terraform
          output_format: json
          output_file_path: checkov-results.json
          # Checkov will report failures but continue-on-error allows pipeline to continue
          soft_fail: false
          skip_check: CKV_AWS_79,CKV2_AWS_41,CKV_AWS_18

      - name: Upload Checkov JSON Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: checkov-scan-results
          path: checkov-results.json
          retention-days: 30

      # -----------------------------------------------------------------------
      # Gitleaks - Secret Scanning
      # -----------------------------------------------------------------------
      - name: Run Gitleaks Secret Scanner
        id: gitleaks
        uses: gitleaks/gitleaks-action@v2
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_CONFIG: .gitleaks.toml

      # -----------------------------------------------------------------------
      # Fail Job if Any Scanner Detected Issues
      # -----------------------------------------------------------------------
      - name: Check Security Scan Results
        if: always()
        run: |
          TRIVY_STATUS="${{ steps.trivy.outcome }}"
          CHECKOV_STATUS="${{ steps.checkov.outcome }}"
          GITLEAKS_STATUS="${{ steps.gitleaks.outcome }}"

          echo "## ðŸ” Phase 2: Security Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Scanner Status:**" >> $GITHUB_STEP_SUMMARY
          echo "- Trivy: $TRIVY_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "- Checkov: $CHECKOV_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "- Gitleaks: $GITLEAKS_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check if any scanner failed
          if [ "$TRIVY_STATUS" == "failure" ] || [ "$CHECKOV_STATUS" == "failure" ] || [ "$GITLEAKS_STATUS" == "failure" ]; then
            echo "âŒ **SECURITY ISSUES DETECTED!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Blocking Deployment:**" >> $GITHUB_STEP_SUMMARY

            if [ "$TRIVY_STATUS" == "failure" ]; then
              echo "- ðŸš¨ Trivy found vulnerabilities (CRITICAL/HIGH/MEDIUM)" >> $GITHUB_STEP_SUMMARY
            fi
            if [ "$CHECKOV_STATUS" == "failure" ]; then
              echo "- ðŸ”’ Checkov found security/compliance violations" >> $GITHUB_STEP_SUMMARY
            fi
            if [ "$GITLEAKS_STATUS" == "failure" ]; then
              echo "- ðŸ”‘ Gitleaks detected secrets in code" >> $GITHUB_STEP_SUMMARY
            fi

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“¥ **Download Results:** Check the 'Artifacts' section for detailed reports" >> $GITHUB_STEP_SUMMARY
            exit 1
          else
            echo "âœ… **All security scans passed!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“¥ **Download Results:** Check the 'Artifacts' section below for JSON reports:" >> $GITHUB_STEP_SUMMARY
            echo "- trivy-scan-results.json" >> $GITHUB_STEP_SUMMARY
            echo "- checkov-scan-results.json" >> $GITHUB_STEP_SUMMARY
          fi

  # ===========================================================================
  # Phase 2 - Job 2: Policy Validation with OPA
  # ===========================================================================
  policy-check:
    name: "Phase 2: Policy Validation (OPA)"
    runs-on: ubuntu-latest
    needs: security-scan

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # -----------------------------------------------------------------------
      # Configure AWS Credentials (REQUIRED for Terraform Plan)
      # -----------------------------------------------------------------------
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      # -----------------------------------------------------------------------
      # Install OPA
      # -----------------------------------------------------------------------
      - name: Install Open Policy Agent
        run: |
          curl -L -o opa https://openpolicyagent.org/downloads/latest/opa_linux_amd64
          chmod +x opa
          sudo mv opa /usr/local/bin/

      - name: Verify OPA Installation
        run: opa version

      # -----------------------------------------------------------------------
      # Validate OPA Policies
      # -----------------------------------------------------------------------
      - name: Validate OPA Policy Syntax
        run: |
          echo "Validating OPA policy files..."
          for policy in policies/*.rego; do
            echo "Checking $policy"
            opa check "$policy"
          done

      # -----------------------------------------------------------------------
      # Test Policies Against Terraform Plan
      # -----------------------------------------------------------------------
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Generate Terraform Plan JSON
        working-directory: terraform
        run: |
          terraform init -reconfigure
          terraform plan -out=tfplan.binary
          terraform show -json tfplan.binary > tfplan.json

      - name: Run OPA Policy Tests on Production Code
        working-directory: terraform
        run: |
          echo "## ðŸ“‹ Policy Validation Results (Production Code)" > policy-results.txt
          failures=0

          # Initialize JSON structure
          echo '{"production_code": {"policies": [], "summary": {"total_policies": 3, "policies_with_violations": 0, "total_violations": 0, "status": "passed"}}}' > ../opa-results.json

          for policy in s3_encryption security_groups required_tags; do
            echo "### Testing $policy Policy" >> policy-results.txt
            # Use the correct package path based on policy name
            package_path="terraform.${policy}"
            out=$(opa eval --format=json --data ../policies/${policy}.rego --input tfplan.json "data.${package_path}.deny" 2>&1 || true)
            echo "$out" >> policy-results.txt

            # Parse JSON output to check if deny array has elements
            deny_count=$(echo "$out" | jq -r '.result[0].expressions[0].value | length' 2>/dev/null || echo "0")
            violations=$(echo "$out" | jq -r '.result[0].expressions[0].value // []' 2>/dev/null || echo "[]")

            # Update JSON results
            policy_json=$(jq -n \
              --arg policy "$policy" \
              --argjson count "$deny_count" \
              --argjson violations "$violations" \
              --arg status "$([ "$deny_count" -gt 0 ] && echo "failed" || echo "passed")" \
              '{name: $policy, violations_count: $count, status: $status, violations: $violations}')

            jq ".production_code.policies += [$policy_json]" ../opa-results.json > ../opa-results.tmp && mv ../opa-results.tmp ../opa-results.json

            if [ "$deny_count" -gt 0 ]; then
              echo "âŒ Violations found in $policy policy ($deny_count violations)" >> policy-results.txt
              failures=$((failures+1))
              # Update summary
              jq '.production_code.summary.policies_with_violations += 1 | .production_code.summary.total_violations += '$deny_count' | .production_code.summary.status = "failed"' ../opa-results.json > ../opa-results.tmp && mv ../opa-results.tmp ../opa-results.json
            else
              echo "âœ… No violations in $policy policy" >> policy-results.txt
            fi
            echo "" >> policy-results.txt
          done

          cat policy-results.txt

          # Always ensure JSON file exists and is valid, even on failure
          # This allows the test files step to run even if this step fails
          if [ ! -f ../opa-results.json ]; then
            echo '{"production_code": {"policies": [], "summary": {"total_policies": 3, "policies_with_violations": 0, "total_violations": 0, "status": "passed"}}}' > ../opa-results.json
          fi

          if [ "$failures" -gt 0 ]; then
            echo "OPA policy violations detected in production code ($failures policies failed)." >&2
            # Exit with failure, but test files step will still run due to if: always()
            exit 1
          fi

      # -----------------------------------------------------------------------
      # Test OPA Policies Against Test Files
      # -----------------------------------------------------------------------
      - name: Test OPA Policies Against Test Files
        if: always() # Run even if previous step failed
        run: |
          echo "## ðŸ§ª Testing OPA Policies Against Test Files" > test-policy-results.txt
          echo "" >> test-policy-results.txt
          test_failures=0
          test_successes=0

          # Initialize test files section in JSON (read from terraform directory)
          if [ -f terraform/opa-results.json ]; then
            cp terraform/opa-results.json opa-results.json
          else
            echo '{"production_code": {"policies": [], "summary": {"total_policies": 3, "policies_with_violations": 0, "total_violations": 0, "status": "passed"}}}' > opa-results.json
          fi
          jq '.test_files = {"files": [], "summary": {"total_files": 0, "expected_violations_detected": 0, "missing_violations": 0, "status": "passed"}}' opa-results.json > opa-results.tmp && mv opa-results.tmp opa-results.json

          # Create a temporary directory for test plans
          mkdir -p test-plans

          test_file_count=0

          # Test each test file
          for test_file in tests/opa_*.tf; do
            if [ ! -f "$test_file" ]; then
              continue
            fi

            test_file_count=$((test_file_count+1))
            test_name=$(basename "$test_file" .tf)
            echo "### Testing: $test_name" >> test-policy-results.txt

            # Create a temporary directory for this test
            test_dir="test-plans/${test_name}"
            mkdir -p "$test_dir"

            # Copy test file and create a minimal Terraform setup
            cp "$test_file" "$test_dir/main.tf"

            # Create a minimal provider.tf for the test
            echo 'terraform {' > "$test_dir/provider.tf"
            echo '  required_version = ">= 1.0"' >> "$test_dir/provider.tf"
            echo '  required_providers {' >> "$test_dir/provider.tf"
            echo '    aws = {' >> "$test_dir/provider.tf"
            echo '      source  = "hashicorp/aws"' >> "$test_dir/provider.tf"
            echo '      version = "~> 5.0"' >> "$test_dir/provider.tf"
            echo '    }' >> "$test_dir/provider.tf"
            echo '    random = {' >> "$test_dir/provider.tf"
            echo '      source  = "hashicorp/random"' >> "$test_dir/provider.tf"
            echo '      version = "~> 3.0"' >> "$test_dir/provider.tf"
            echo '    }' >> "$test_dir/provider.tf"
            echo '  }' >> "$test_dir/provider.tf"
            echo '}' >> "$test_dir/provider.tf"
            echo '' >> "$test_dir/provider.tf"
            echo 'provider "aws" {' >> "$test_dir/provider.tf"
            echo '  region = "us-east-1"' >> "$test_dir/provider.tf"
            echo '}' >> "$test_dir/provider.tf"

            # Generate Terraform plan for this test
            cd "$test_dir"
            terraform init -backend=false > /dev/null 2>&1 || true
            terraform plan -out=tfplan.binary > /dev/null 2>&1 || true

            # Initialize test file JSON structure
            test_file_json=$(jq -n --arg name "$test_name" --arg file "$test_file" '{name: $name, file: $file, policies: [], status: "passed"}')

            if [ -f "tfplan.binary" ]; then
              terraform show -json tfplan.binary > tfplan.json 2>/dev/null || true

              if [ -f "tfplan.json" ]; then
                # Test each policy
                for policy in s3_encryption security_groups required_tags; do
                  package_path="terraform.${policy}"
                  out=$(opa eval --format=json --data ../../../policies/${policy}.rego --input tfplan.json "data.${package_path}.deny" 2>&1 || true)

                  # Parse JSON output to check if deny array has elements
                  deny_count=$(echo "$out" | jq -r '.result[0].expressions[0].value | length' 2>/dev/null || echo "0")
                  violations=$(echo "$out" | jq -r '.result[0].expressions[0].value // []' 2>/dev/null || echo "[]")

                  # Add policy result to test file JSON
                  policy_result=$(jq -n \
                    --arg policy "$policy" \
                    --argjson count "$deny_count" \
                    --argjson violations "$violations" \
                    --arg status "$([ "$deny_count" -gt 0 ] && echo "passed" || echo "failed")" \
                    '{name: $policy, violations_count: $count, status: $status, violations: $violations}')

                  test_file_json=$(echo "$test_file_json" | jq ".policies += [$policy_result]")

                  # Check if violations were found
                  if [ "$deny_count" -gt 0 ]; then
                    echo "  âœ… $policy: $deny_count violation(s) detected (expected)" >> ../../../test-policy-results.txt
                    test_successes=$((test_successes+1))
                  else
                    echo "  âŒ $policy: No violations detected (unexpected for test file)" >> ../../../test-policy-results.txt
                    test_failures=$((test_failures+1))
                    test_file_json=$(echo "$test_file_json" | jq '.status = "failed"')
                  fi
                done
              else
                echo "  âš ï¸ Could not generate plan JSON for $test_name" >> ../../../test-policy-results.txt
                test_file_json=$(echo "$test_file_json" | jq '.status = "error" | .error = "Could not generate plan JSON"')
              fi
            else
              echo "  âš ï¸ Could not generate plan for $test_name" >> ../../../test-policy-results.txt
              test_file_json=$(echo "$test_file_json" | jq '.status = "error" | .error = "Could not generate plan"')
            fi

            # Add test file to JSON results
            jq ".test_files.files += [$test_file_json]" ../opa-results.json > ../opa-results.tmp && mv ../opa-results.tmp ../opa-results.json

            cd ../..
            echo "" >> test-policy-results.txt
          done

          # Update test files summary
          jq --argjson total "$test_file_count" \
             --argjson successes "$test_successes" \
             --argjson failures "$test_failures" \
             '.test_files.summary.total_files = $total |
              .test_files.summary.expected_violations_detected = $successes |
              .test_files.summary.missing_violations = $failures |
              .test_files.summary.status = (if $failures > 0 then "warning" else "passed" end)' \
             opa-results.json > opa-results.tmp && mv opa-results.tmp opa-results.json

          echo "### Test Summary" >> test-policy-results.txt
          echo "- Expected violations detected: $test_successes" >> test-policy-results.txt
          echo "- Missing violations (policies not working): $test_failures" >> test-policy-results.txt
          echo "" >> test-policy-results.txt

          cat test-policy-results.txt

          if [ "$test_failures" -gt 0 ]; then
            echo "âš ï¸ Some OPA policies are not detecting violations in test files!" >&2
            echo "This indicates the policies may need adjustment." >&2
          fi

          # Add metadata to JSON
          jq --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
             --arg workflow "${{ github.workflow }}" \
             --arg run_id "${{ github.run_id }}" \
             --arg commit "${{ github.sha }}" \
             '.metadata = {
               timestamp: $timestamp,
               workflow: $workflow,
               run_id: $run_id,
               commit: $commit,
               repository: "${{ github.repository }}"
             }' \
             opa-results.json > opa-results.tmp && mv opa-results.tmp opa-results.json

      # -----------------------------------------------------------------------
      # Upload OPA Results as Artifact
      # -----------------------------------------------------------------------
      - name: Upload OPA Results JSON
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: opa-policy-results
          path: opa-results.json
          retention-days: 30

      # -----------------------------------------------------------------------
      # Summary
      # -----------------------------------------------------------------------
      - name: Policy Check Summary
        if: always()
        run: |
          echo "## ðŸ“‹ Phase 2: Policy Validation Results (OPA)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Read JSON results
          if [ -f opa-results.json ]; then
            # Production Code Summary
            prod_status=$(jq -r '.production_code.summary.status' opa-results.json)
            prod_violations=$(jq -r '.production_code.summary.total_violations' opa-results.json)
            prod_policies_failed=$(jq -r '.production_code.summary.policies_with_violations' opa-results.json)

            echo "### ðŸ”’ Production Code Validation" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "$prod_status" = "failed" ]; then
              echo "âŒ **Status:** FAILED - $prod_policies_failed policy/policies with violations" >> $GITHUB_STEP_SUMMARY
              echo "ðŸš¨ **Total Violations:** $prod_violations" >> $GITHUB_STEP_SUMMARY
            else
              echo "âœ… **Status:** PASSED - No violations detected" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY

            # Policy Details
            echo "**Policy Details:**" >> $GITHUB_STEP_SUMMARY
            jq -r '.production_code.policies[] | "- \(if .status == "failed" then "âŒ" else "âœ…" end) **\(.name)**: \(.violations_count) violation(s)"' opa-results.json >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Test Files Summary
            test_status=$(jq -r '.test_files.summary.status' opa-results.json)
            test_total=$(jq -r '.test_files.summary.total_files' opa-results.json)
            test_successes=$(jq -r '.test_files.summary.expected_violations_detected' opa-results.json)
            test_failures=$(jq -r '.test_files.summary.missing_violations' opa-results.json)

            echo "### ðŸ§ª Test Files Validation" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Test Files Analyzed:** $test_total" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Expected violations detected: $test_successes" >> $GITHUB_STEP_SUMMARY
            if [ "$test_failures" -gt 0 ]; then
              echo "- âš ï¸ Missing violations (policies may need adjustment): $test_failures" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY

            # Overall Status
            echo "### ðŸ“Š Overall Status" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            if [ "$prod_status" = "failed" ]; then
              echo "ðŸš¨ **DEPLOYMENT BLOCKED** - Policy violations detected in production code" >> $GITHUB_STEP_SUMMARY
            else
              echo "âœ… **DEPLOYMENT ALLOWED** - All policies passed" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY

            # Download Link
            echo "ðŸ“¥ **Download Results:** Check the 'Artifacts' section below for detailed JSON report:" >> $GITHUB_STEP_SUMMARY
            echo "- opa-policy-results.json (Complete policy validation results)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Violations Details (if any)
            if [ "$prod_violations" -gt 0 ]; then
              echo "### ðŸš¨ Violations Details" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              jq -r '.production_code.policies[] | select(.violations_count > 0) | "Policy: \(.name)\nViolations (\(.violations_count)):\n\(.violations[] | "- \(.)")\n"' opa-results.json >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi

            echo "âš ï¸ **Security Gate:** Deployment blocked if production code policies fail" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ OPA results file not found" >> $GITHUB_STEP_SUMMARY
          fi

  # ===========================================================================
  # Phase 3: Deployment to AWS with Manual Approval
  # ===========================================================================
  deploy:
    name: "Phase 3: Deploy to AWS"
    runs-on: ubuntu-latest
    needs: [security-scan, policy-check] # âœ… DEPENDENCY: Both Phase 2 jobs must pass

    # Only run on push to main (not on PRs)
    if: |
      github.ref == 'refs/heads/main' &&
      github.event_name == 'push' &&
      github.event.inputs.skip_deployment != 'true'

    # Manual approval required via GitHub Environment
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # -----------------------------------------------------------------------
      # Setup Terraform
      # -----------------------------------------------------------------------
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      # -----------------------------------------------------------------------
      # Configure AWS Credentials
      # -----------------------------------------------------------------------
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Verify AWS Identity
        run: |
          echo "## ðŸ” AWS Identity" >> $GITHUB_STEP_SUMMARY
          aws sts get-caller-identity >> $GITHUB_STEP_SUMMARY

      # -----------------------------------------------------------------------
      # Terraform Init
      # -----------------------------------------------------------------------
      - name: Terraform Init
        working-directory: terraform
        run: terraform init -reconfigure

      # -----------------------------------------------------------------------
      # Terraform Plan
      # -----------------------------------------------------------------------
      - name: Terraform Plan
        working-directory: terraform
        id: plan
        run: |
          terraform plan -no-color -out=tfplan
          terraform show -no-color tfplan > tfplan.txt

      - name: Display Terraform Plan
        working-directory: terraform
        run: |
          echo "## ðŸ“‹ Terraform Plan" >> $GITHUB_STEP_SUMMARY
          echo '```terraform' >> $GITHUB_STEP_SUMMARY
          cat tfplan.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      # -----------------------------------------------------------------------
      # Terraform Apply (Manual approval required via 'environment: production')
      # -----------------------------------------------------------------------
      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve tfplan

      # -----------------------------------------------------------------------
      # Capture Outputs
      # -----------------------------------------------------------------------
      - name: Terraform Outputs
        working-directory: terraform
        run: |
          echo "## ðŸŽ‰ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Deployed Resources:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          terraform output -json | jq >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      # -----------------------------------------------------------------------
      # Summary
      # -----------------------------------------------------------------------
      - name: Deployment Summary
        if: always()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** Infrastructure deployed to AWS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **Remember:** Run \`terraform destroy\` after testing to avoid costs" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # Phase 4: Drift Detection with Driftctl
  # ===========================================================================
  drift-detection:
    name: "Phase 4: Drift Detection"
    runs-on: ubuntu-latest
    needs: deploy # âœ… DEPENDENCY: Only run after successful deployment

    # Only run after deployment completes
    if: |
      github.ref == 'refs/heads/main' &&
      github.event_name == 'push'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # -----------------------------------------------------------------------
      # Install Driftctl
      # -----------------------------------------------------------------------
      - name: Install Driftctl
        run: |
          curl -L https://github.com/snyk/driftctl/releases/latest/download/driftctl_linux_amd64 -o driftctl
          chmod +x driftctl
          sudo mv driftctl /usr/local/bin/

      - name: Verify Driftctl Installation
        run: driftctl version

      # -----------------------------------------------------------------------
      # Configure AWS Credentials
      # -----------------------------------------------------------------------
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      # -----------------------------------------------------------------------
      # Setup Terraform for State Comparison
      # -----------------------------------------------------------------------
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Terraform Init
        working-directory: terraform
        run: terraform init -reconfigure

      # -----------------------------------------------------------------------
      # Run Drift Detection
      # -----------------------------------------------------------------------
      - name: Run Driftctl Scan
        run: |
          cd terraform
          driftctl scan --from tfstate://terraform.tfstate --output console://,json://drift-report.json
        continue-on-error: true # Don't fail workflow if drift found

      - name: Parse Drift Results
        if: always()
        working-directory: terraform
        run: |
          if [ -f drift-report.json ]; then
            echo "## ðŸ” Phase 4: Drift Detection Results" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Count resources
            TOTAL=$(jq '.summary.total_resources' drift-report.json)
            MANAGED=$(jq '.summary.total_managed' drift-report.json)
            UNMANAGED=$(jq '.summary.total_unmanaged' drift-report.json)
            DRIFT=$(jq '.summary.total_changed' drift-report.json)

            echo "**Summary:**" >> $GITHUB_STEP_SUMMARY
            echo "- Total Resources: $TOTAL" >> $GITHUB_STEP_SUMMARY
            echo "- Managed by Terraform: $MANAGED" >> $GITHUB_STEP_SUMMARY
            echo "- Unmanaged Resources: $UNMANAGED" >> $GITHUB_STEP_SUMMARY
            echo "- Resources with Drift: $DRIFT" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if [ "$DRIFT" -gt 0 ]; then
              echo "âš ï¸ **DRIFT DETECTED!** Manual changes found in AWS infrastructure" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**Action Required:**" >> $GITHUB_STEP_SUMMARY
              echo "1. Review the drift report above" >> $GITHUB_STEP_SUMMARY
              echo "2. Choose remediation: Revert in AWS, Update Terraform, or Re-apply" >> $GITHUB_STEP_SUMMARY
            else
              echo "âœ… **NO DRIFT DETECTED** - Infrastructure matches Terraform state" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "âš ï¸ Drift report not generated" >> $GITHUB_STEP_SUMMARY
          fi

      # -----------------------------------------------------------------------
      # Upload Drift Report as Artifact
      # -----------------------------------------------------------------------
      - name: Upload Drift Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: drift-report
          path: terraform/drift-report.json
          retention-days: 30

      # -----------------------------------------------------------------------
      # Create GitHub Issue if Drift Detected (Optional)
      # -----------------------------------------------------------------------
      - name: Create Drift Alert Issue
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const reportPath = 'terraform/drift-report.json';

            // 1. Check if the report file actually exists
            if (!fs.existsSync(reportPath)) {
              console.log('âš ï¸ Drift report not found. Skipping issue creation.');
              return;
            }

            // 2. Read and parse the file safely
            try {
              const driftReport = JSON.parse(fs.readFileSync(reportPath, 'utf8'));

              if (driftReport.summary.total_changed > 0) {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: 'âš ï¸ Infrastructure Drift Detected',
                  body: `## Drift Detection Alert

                  **Drift detected in AWS infrastructure!**

                  **Summary:**
                  - Resources with drift: ${driftReport.summary.total_changed}
                  - Total managed resources: ${driftReport.summary.total_managed}
                  - Unmanaged resources: ${driftReport.summary.total_unmanaged}

                  **Action Required:**
                  1. Review the [workflow run](${context.payload.repository.html_url}/actions/runs/${context.runId})
                  2. Download the drift report artifact
                  3. Choose remediation strategy:
                     - **Revert in AWS:** Manual fix in AWS Console
                     - **Update Terraform:** Accept change, update IaC
                     - **Re-apply Terraform:** Force infrastructure to match state

                  **Workflow:** ${context.workflow}
                  **Run ID:** ${context.runId}
                  **Triggered by:** ${context.actor}
                  `,
                  labels: ['drift-detection', 'security', 'infrastructure']
                });
              }
            } catch (error) {
              console.log('Error parsing drift report: ' + error.message);
            }

  # ===========================================================================
  # Summary Job: Overall Pipeline Status
  # ===========================================================================
  pipeline-summary:
    name: "Pipeline Summary"
    runs-on: ubuntu-latest
    needs: [security-scan, policy-check, deploy, drift-detection]
    if: always()

    steps:
      - name: Pipeline Summary
        run: |
          echo "# ðŸŽ‰ Complete DevSecOps Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Execution Flow:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. âœ… **Phase 2: Security Scan** - Trivy + Checkov + Gitleaks" >> $GITHUB_STEP_SUMMARY
          echo "2. âœ… **Phase 2: Policy Check** - OPA validation" >> $GITHUB_STEP_SUMMARY
          echo "3. âœ… **Phase 3: Deployment** - Terraform to AWS (manual approval)" >> $GITHUB_STEP_SUMMARY
          echo "4. âœ… **Phase 4: Drift Detection** - Driftctl scan" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Defense-in-Depth Validation:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Security scans MUST pass before policy check" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Policy check MUST pass before deployment" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Manual approval REQUIRED before deployment" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Drift detection runs ONLY after successful deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Result:** Complete audit trail with enforced security gates ðŸ”’" >> $GITHUB_STEP_SUMMARY
